# RBAC (Role-Based Access Control) Implementation Guide

> **Generated by**: Cursor AI Assistant  
> **Created**: 2025-01-07  
> **Last Updated**: 2025-01-07  
> **Status**: Planning  
> **GitHub Issue**: [#11](https://github.com/kevinerdogan/prolinkli-java-core/issues/11)

## 🎯 Objective

Implement a foundational role-based access control (RBAC) system that allows developers to easily restrict access to features and data based on authenticated user roles, using Spring Security annotations like `@PreAuthorize("hasRole('ADMIN')")`.

## 🔍 Introspective Analysis

### Business Requirements
- **Primary Goal**: Enable secure access control through role-based restrictions
- **Success Criteria**: Developers can secure endpoints and methods with simple annotations
- **User Impact**: Users will only access features appropriate to their assigned roles

### Technical Analysis
- **Integration Points**: Spring Security, existing User system, MyBatis, database
- **Dependencies**: Spring Security, existing authentication system, database tables
- **Constraints**: Must work with existing User model and authentication flow
- **Assumptions**: Users can have multiple roles, roles are stored in database

### Risk Assessment
- **High Risk**: Breaking existing authentication flow, role hierarchy conflicts
- **Medium Risk**: Performance impact from role lookups, migration complexity
- **Mitigation Strategies**: Incremental implementation, comprehensive testing

## 📋 Implementation Checklist

### Phase 1: Database Schema & Migration
- [ ] **Database Migration**: Create roles and user_roles tables
  - [ ] Create `roles` table with role definitions
  - [ ] Create `user_roles` join table
  - [ ] Add foreign key constraints
  - [ ] Create indexes for performance
- [ ] **MyBatis Integration**: Generate mappers and models
  - [ ] Update mybatis-generator-config.xml
  - [ ] Run MyBatis generator
  - [ ] Verify generated Role and UserRole models
- [ ] **Database Testing**: Validate schema and relationships
  - [ ] Test role creation and assignment
  - [ ] Test cascade delete behavior
  - [ ] Verify foreign key constraints work

### Phase 2: Spring Security Configuration
- [ ] **Security Configuration**: Enable method security
  - [ ] Add @EnableGlobalMethodSecurity annotation
  - [ ] Configure prePostEnabled = true
  - [ ] Update SecurityConfig for role-based authorization
- [ ] **UserDetailsService**: Implement role loading
  - [ ] Create custom UserDetailsService implementation
  - [ ] Load user roles from database
  - [ ] Map roles to Spring Security authorities
- [ ] **Authentication Integration**: Connect with existing auth
  - [ ] Update existing authentication providers
  - [ ] Ensure roles are loaded during login
  - [ ] Test JWT token integration with roles

### Phase 3: Core Business Logic
- [ ] **Domain Models**: Create role management objects
  - [ ] Role business model
  - [ ] UserRole association model
  - [ ] User model updates for role integration
- [ ] **Service Layer**: Implement role management logic
  - [ ] RoleService for CRUD operations
  - [ ] UserRoleService for role assignments
  - [ ] Integration with existing UserService
- [ ] **DAO Integration**: Connect services to data layer
  - [ ] Configure DAO factories for new tables
  - [ ] Implement efficient role lookup queries

### Phase 4: API & Controllers
- [ ] **Role Management Endpoints**: Create admin role management
  - [ ] GET /api/roles - List all roles
  - [ ] POST /api/roles - Create new role
  - [ ] PUT /api/users/{id}/roles - Assign roles to user
  - [ ] DELETE /api/users/{id}/roles/{roleId} - Remove role from user
- [ ] **Security Annotations**: Protect endpoints with @PreAuthorize
  - [ ] Secure role management endpoints
  - [ ] Add role checks to existing controllers
  - [ ] Test authorization enforcement
- [ ] **Request/Response Models**: Define role API contracts
- [ ] **Error Handling**: Add proper access denied handling

### Phase 5: Integration & Testing
- [ ] **Unit Tests**: Test role management components
  - [ ] RoleService tests
  - [ ] UserDetailsService tests
  - [ ] Security configuration tests
- [ ] **Integration Tests**: Test role-based access control
  - [ ] Test @PreAuthorize annotations
  - [ ] Test role assignment workflows
  - [ ] Test authentication with roles
- [ ] **Security Testing**: Validate access controls
  - [ ] Test unauthorized access attempts
  - [ ] Test role escalation prevention
  - [ ] Test edge cases and error scenarios

### Phase 6: Documentation & Deployment
- [ ] **Code Documentation**: Add comprehensive JavaDoc
  - [ ] Document security annotations usage
  - [ ] Document role management APIs
  - [ ] Update existing auth documentation
- [ ] **Usage Examples**: Provide implementation examples
  - [ ] Controller security examples
  - [ ] Service method security examples
  - [ ] Role assignment examples
- [ ] **Migration Guide**: Prepare production deployment
  - [ ] Database migration scripts
  - [ ] Role seeding for existing users
  - [ ] Rollback procedures

## 🏗️ Implementation Details

### Database Schema

```sql
-- liquibase formatted sql
-- changeset rbac:CreateRolesSystem splitStatements:false

-- Roles table
select create_table(
  table_name => 'roles',
  columns => 'id BIGSERIAL UNIQUE NOT NULL,
              role_name VARCHAR(50) NOT NULL UNIQUE,
              description VARCHAR(255),',
  options => '{
    "schema": "public",
    "add_soft_delete": false,
    "primary_key": "id",
    "comment": "System roles for access control",
    "if_not_exists": true,
    "add_timestamps": true
  }'
);

-- User roles junction table
select create_table(
  table_name => 'user_roles',
  columns => 'user_id BIGINT NOT NULL,
              role_id BIGINT NOT NULL,',
  foreign_keys => '[
    {
      "column": "user_id",
      "references": "users(id)",
      "if_not_exists": true,
      "on_delete": "CASCADE"
    },
    {
      "column": "role_id",
      "references": "roles(id)",
      "if_not_exists": true,
      "on_delete": "CASCADE"
    }
  ]',
  options => '{
    "schema": "public",
    "add_soft_delete": false,
    "primary_key": "user_id, role_id",
    "comment": "Associates users with their assigned roles",
    "if_not_exists": true,
    "add_timestamps": true
  }'
);

-- Insert default roles
INSERT INTO roles (role_name, description) VALUES
('ROLE_ADMIN', 'Administrator with full system access'),
('ROLE_USER', 'Standard user with basic access'),
('ROLE_PROFESSIONAL', 'Professional user with extended access'),
('ROLE_CONSUMER', 'Consumer user with limited access');
```

### Spring Security Configuration

```java
@Configuration
@EnableWebSecurity
@EnableGlobalMethodSecurity(prePostEnabled = true, securedEnabled = true, jsr250Enabled = true)
public class SecurityConfig {

    @Autowired
    private CustomUserDetailsService userDetailsService;

    @Bean
    public PasswordEncoder passwordEncoder() {
        return new BCryptPasswordEncoder();
    }

    @Bean
    public AuthenticationManager authenticationManager(
            AuthenticationConfiguration config) throws Exception {
        return config.getAuthenticationManager();
    }

    @Bean
    public DaoAuthenticationProvider authenticationProvider() {
        DaoAuthenticationProvider authProvider = new DaoAuthenticationProvider();
        authProvider.setUserDetailsService(userDetailsService);
        authProvider.setPasswordEncoder(passwordEncoder());
        return authProvider;
    }

    @Override
    protected void configure(HttpSecurity http) throws Exception {
        http.csrf().disable()
            .authorizeHttpRequests(authz -> authz
                .requestMatchers("/api/auth/**").permitAll()
                .requestMatchers("/api/admin/**").hasRole("ADMIN")
                .requestMatchers("/api/professional/**").hasRole("PROFESSIONAL")
                .anyRequest().authenticated()
            )
            .sessionManagement()
                .sessionCreationPolicy(SessionCreationPolicy.STATELESS);
    }
}
```

### UserDetailsService Implementation

```java
@Service
public class CustomUserDetailsService implements UserDetailsService {

    @Autowired
    private UserGetService userGetService;
    
    @Autowired
    private RoleService roleService;

    @Override
    @Transactional(readOnly = true)
    public UserDetails loadUserByUsername(String username) throws UsernameNotFoundException {
        User user = userGetService.getUserByUsername(username);
        if (user == null) {
            throw new UsernameNotFoundException("User not found: " + username);
        }

        List<Role> userRoles = roleService.getUserRoles(user.getId());
        List<GrantedAuthority> authorities = userRoles.stream()
            .map(role -> new SimpleGrantedAuthority(role.getRoleName()))
            .collect(Collectors.toList());

        return new CustomUserPrincipal(
            user.getId(),
            user.getUsername(),
            "", // password handled separately
            authorities
        );
    }
}
```

### Controller Security Examples

```java
@RestController
@RequestMapping("/api/admin")
public class AdminController {

    @GetMapping("/users")
    @PreAuthorize("hasRole('ADMIN')")
    public List<User> getAllUsers() {
        return userService.getAllUsers();
    }

    @PostMapping("/users/{userId}/roles")
    @PreAuthorize("hasRole('ADMIN')")
    public ResponseObject<String> assignRole(
            @PathVariable Long userId,
            @RequestParam String roleName) {
        roleService.assignRoleToUser(userId, roleName);
        return ResponseObject.success("Role assigned successfully");
    }
}

@RestController
@RequestMapping("/api/quotes")
public class QuoteController {

    @PostMapping
    @PreAuthorize("hasRole('PROFESSIONAL') or hasRole('ADMIN')")
    public ResponseObject<Quote> createQuote(@RequestBody QuoteRequest request) {
        return ResponseObject.success(quoteService.createQuote(request));
    }

    @DeleteMapping("/{id}")
    @PreAuthorize("hasRole('ADMIN')")
    public ResponseObject<String> deleteQuote(@PathVariable Long id) {
        quoteService.deleteQuote(id);
        return ResponseObject.success("Quote deleted");
    }
}
```

## 🔗 Dependencies & Integration Points

### Existing Components
- **User System**: Extends existing User model and authentication
- **MyBatis**: Uses existing DAO patterns for role data access
- **JWT Service**: Integrates roles into JWT token claims
- **Security Config**: Enhances existing security configuration

### New Dependencies
- **Spring Security Method Security**: For @PreAuthorize annotations
- **Spring Security Core**: For UserDetailsService integration

## 🧪 Testing Strategy

### Test Scenarios
1. **Role Assignment**: Users can be assigned and unassigned roles
2. **Authorization Checks**: @PreAuthorize annotations work correctly
3. **Role Hierarchy**: Admin role can access all endpoints
4. **Unauthorized Access**: Users without proper roles are denied access

### Test Data Requirements
- **Test Users**: Users with different role combinations
- **Test Roles**: Standard set of roles for testing scenarios
- **Test Endpoints**: Secured and unsecured endpoints for validation

## 🚀 Deployment Considerations

### Environment Variables
No additional environment variables required - uses existing database configuration.

### Database Migrations
1. **Create Roles Tables**: Add roles and user_roles tables
2. **Seed Default Roles**: Insert standard system roles
3. **Assign Default Roles**: Assign roles to existing users

### Rollback Plan
1. **Remove Role Checks**: Disable @PreAuthorize annotations
2. **Preserve User Access**: Ensure existing users maintain access
3. **Database Rollback**: Drop new tables if needed

## 📊 Success Metrics
- **Authorization Coverage**: All sensitive endpoints protected with role checks
- **Performance Impact**: Role lookup adds minimal latency (<10ms)
- **Security Compliance**: All access attempts properly authorized

## 🔄 Next Steps
1. **Immediate**: Create database migration for roles tables
2. **Short-term**: Implement UserDetailsService with role loading
3. **Long-term**: Extend with permission-based access control if needed

---
**Implementation Status**: ⏳ Planning  
**Review Required**: Yes - by security team and lead developer