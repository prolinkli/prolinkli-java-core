# Comprehensive Access Control Implementation Guide

> **Generated by**: Cursor AI Assistant  
> **Created**: 2025-01-07  
> **Last Updated**: 2025-01-07  
> **Status**: Planning  
> **GitHub Issue**: [#11](https://github.com/kevinerdogan/prolinkli-java-core/issues/11)

## 🎯 Objective

Implement a comprehensive access control system that provides both simple role-based access control (RBAC) for basic authorization needs and an advanced permissions system for fine-grained access control, allowing developers to choose the appropriate level of complexity for each use case.

## 🔍 Introspective Analysis

### Business Requirements
- **Primary Goal**: Enable both simple role-based restrictions and complex permission-based access control
- **Success Criteria**: Developers can use simple `@PreAuthorize("hasRole('ADMIN')")` for basic needs and detailed permission checking for complex scenarios
- **User Impact**: Users have appropriate access based on both their roles and specific permissions

### Technical Analysis
- **Integration Points**: Spring Security, existing User system, MyBatis, database
- **Dependencies**: Spring Security, existing authentication system, database tables
- **Constraints**: Must work with existing User model and authentication flow
- **Assumptions**: Users can have multiple roles and permissions, gradual migration from simple to complex

### Risk Assessment
- **High Risk**: Breaking existing authentication flow, complexity overwhelming developers
- **Medium Risk**: Performance impact from permission lookups, migration complexity
- **Mitigation Strategies**: Phased implementation starting with RBAC, comprehensive testing

## 📋 Implementation Checklist

### Phase 1: Foundation - RBAC System
- [ ] **Database Migration**: Create roles and user_roles tables
  - [ ] Create `roles` table with role definitions
  - [ ] Create `user_roles` join table
  - [ ] Add foreign key constraints and indexes
- [ ] **Spring Security Configuration**: Enable method security
  - [ ] Add @EnableGlobalMethodSecurity annotation
  - [ ] Configure prePostEnabled = true
  - [ ] Update SecurityConfig for role-based authorization
- [ ] **UserDetailsService**: Implement role loading
  - [ ] Create custom UserDetailsService implementation
  - [ ] Load user roles from database
  - [ ] Map roles to Spring Security authorities
- [ ] **Basic Role Management**: Implement CRUD for roles
  - [ ] RoleService for basic operations
  - [ ] Role assignment endpoints
  - [ ] Integration with existing UserService

### Phase 2: Advanced Permissions System
- [ ] **Extended Database Schema**: Add permissions tables
  - [ ] Create permissions lookup tables
  - [ ] Create user_permissions table
  - [ ] Add level and target support tables
- [ ] **Permission Models**: Create advanced permission objects
  - [ ] Permission business models
  - [ ] Level and target enums/constants
  - [ ] UserPermission association models
- [ ] **Permission Service**: Implement fine-grained checking
  - [ ] PermissionService with bitwise level checking
  - [ ] Target-based access control
  - [ ] Integration with role system
- [ ] **Unified Access Control**: Combine roles and permissions
  - [ ] AccessControlService that checks both
  - [ ] Fallback mechanisms
  - [ ] Performance optimization

### Phase 3: API & Controllers
- [ ] **Role Management Endpoints**: Basic role operations
  - [ ] GET /api/roles - List all roles
  - [ ] POST /api/roles - Create new role
  - [ ] PUT /api/users/{id}/roles - Assign roles to user
- [ ] **Permission Management Endpoints**: Advanced permission operations
  - [ ] GET /api/permissions - List available permissions
  - [ ] POST /api/users/{id}/permissions - Grant specific permissions
  - [ ] GET /api/users/{id}/access - Check user access capabilities
- [ ] **Security Annotations**: Protect endpoints
  - [ ] Use @PreAuthorize for simple role checks
  - [ ] Use custom annotations for permission checks
  - [ ] Test authorization enforcement

### Phase 4: Integration & Testing
- [ ] **Unit Tests**: Test all access control components
  - [ ] Role system tests
  - [ ] Permission system tests
  - [ ] Integration between systems
- [ ] **Security Testing**: Validate access controls
  - [ ] Test role-based access
  - [ ] Test permission-based access
  - [ ] Test unauthorized access attempts
- [ ] **Performance Testing**: Ensure system scales
  - [ ] Benchmark role lookups
  - [ ] Benchmark permission checks
  - [ ] Optimize caching strategies

### Phase 5: Documentation & Migration
- [ ] **Usage Documentation**: Provide clear examples
  - [ ] When to use roles vs permissions
  - [ ] Migration guide from roles to permissions
  - [ ] Best practices and patterns
- [ ] **Deployment**: Prepare production rollout
  - [ ] Database migration scripts
  - [ ] Role and permission seeding
  - [ ] Rollback procedures

## 🏗️ Implementation Details

### Database Schema

#### Phase 1: RBAC Tables

```sql
-- liquibase formatted sql
-- changeset rbac:CreateRolesSystem splitStatements:false

-- Roles table
select create_table(
  table_name => 'roles',
  columns => 'id BIGSERIAL UNIQUE NOT NULL,
              role_name VARCHAR(50) NOT NULL UNIQUE,
              description VARCHAR(255),',
  options => '{
    "schema": "public",
    "add_soft_delete": false,
    "primary_key": "id",
    "comment": "System roles for basic access control",
    "if_not_exists": true,
    "add_timestamps": true
  }'
);

-- User roles junction table
select create_table(
  table_name => 'user_roles',
  columns => 'user_id BIGINT NOT NULL,
              role_id BIGINT NOT NULL,',
  foreign_keys => '[
    {
      "column": "user_id",
      "references": "users(id)",
      "if_not_exists": true,
      "on_delete": "CASCADE"
    },
    {
      "column": "role_id",
      "references": "roles(id)",
      "if_not_exists": true,
      "on_delete": "CASCADE"
    }
  ]',
  options => '{
    "schema": "public",
    "add_soft_delete": false,
    "primary_key": "user_id, role_id",
    "comment": "Associates users with their assigned roles",
    "if_not_exists": true,
    "add_timestamps": true
  }'
);

-- Insert default roles
INSERT INTO roles (role_name, description) VALUES
('ROLE_ADMIN', 'Administrator with full system access'),
('ROLE_USER', 'Standard user with basic access'),
('ROLE_PROFESSIONAL', 'Professional user with extended access'),
('ROLE_CONSUMER', 'Consumer user with limited access');
```

#### Phase 2: Advanced Permissions Tables

```sql
-- liquibase formatted sql
-- changeset permissions:CreateAdvancedPermissions splitStatements:false

-- Permissions lookup table
select create_table(
  table_name => 'permissions_lk',
  columns => 'permission_lk VARCHAR(50) NOT NULL,
              permission_name VARCHAR(100) NOT NULL,
              has_targets_flg BOOLEAN NOT NULL DEFAULT FALSE,
              has_levels_flg BOOLEAN NOT NULL DEFAULT FALSE,
              description VARCHAR(255),',
  options => '{
    "schema": "public",
    "add_soft_delete": false,
    "primary_key": "permission_lk",
    "comment": "Lookup table for permission types",
    "if_not_exists": true,
    "add_timestamps": true
  }'
);

-- Permission levels lookup table
select create_table(
  table_name => 'permissions_levels_lk',
  columns => 'permission_level_lk VARCHAR(15) NOT NULL,
              level_value INTEGER NOT NULL,
              level_name VARCHAR(50) NOT NULL,',
  options => '{
    "schema": "public",
    "add_soft_delete": false,
    "primary_key": "permission_level_lk",
    "comment": "Lookup table for permission levels with bitwise values",
    "if_not_exists": true,
    "add_timestamps": true,
    "unique_constraints": ["level_value"]
  }'
);

-- Permission targets lookup table
select create_table(
  table_name => 'permissions_targets_lk',
  columns => 'permission_target_lk VARCHAR(50) NOT NULL,
              target_name VARCHAR(100) NOT NULL,',
  options => '{
    "schema": "public",
    "add_soft_delete": false,
    "primary_key": "permission_target_lk",
    "comment": "Lookup table for permission targets",
    "if_not_exists": true,
    "add_timestamps": true
  }'
);

-- User permissions table
select create_table(
  table_name => 'user_permissions',
  columns => 'user_permission_id VARCHAR(36) NOT NULL DEFAULT gen_random_uuid(),
              user_id BIGINT NOT NULL,
              permission_lk VARCHAR(50) NOT NULL,
              permission_target_lk VARCHAR(50) NULL,
              permission_level_lk VARCHAR(15) NULL,
              granted_at TIMESTAMPTZ DEFAULT NOW(),
              granted_by BIGINT,',
  foreign_keys => '[
    {
      "column": "user_id",
      "references": "users(id)",
      "if_not_exists": true,
      "on_delete": "CASCADE"
    },
    {
      "column": "permission_lk",
      "references": "permissions_lk(permission_lk)",
      "if_not_exists": true,
      "on_delete": "CASCADE"
    },
    {
      "column": "granted_by",
      "references": "users(id)",
      "if_not_exists": true,
      "on_delete": "SET NULL"
    }
  ]',
  options => '{
    "schema": "public",
    "add_soft_delete": false,
    "primary_key": "user_permission_id",
    "comment": "User-specific permission assignments",
    "if_not_exists": true,
    "add_timestamps": true
  }'
);

-- Seed permission levels
INSERT INTO permissions_levels_lk (permission_level_lk, level_value, level_name) VALUES
('NONE', 0, 'No Access'),
('READ', 1, 'Read Only'),
('EDIT', 3, 'Edit (includes Read)'),
('CREATE', 7, 'Create (includes Read, Edit)'),
('DELETE', 15, 'Delete (includes Read, Edit, Create)');

-- Seed permission targets
INSERT INTO permissions_targets_lk (permission_target_lk, target_name) VALUES
('ALL', 'All Resources'),
('SELF', 'Own Resources Only'),
('PROFESSIONALS', 'Professional Users'),
('CONSUMERS', 'Consumer Users'),
('TEAM', 'Team Members'),
('ORGANIZATION', 'Organization Members');

-- Seed sample permissions
INSERT INTO permissions_lk (permission_lk, permission_name, has_targets_flg, has_levels_flg, description) VALUES
('QUOTE', 'Quote Management', true, true, 'Manage quotes and pricing'),
('USER_MANAGEMENT', 'User Management', true, true, 'Manage user accounts'),
('REPORT', 'Report Access', true, true, 'Access and generate reports'),
('PROFILE', 'Profile Management', false, true, 'Manage user profiles');
```

### Constants Definition

```java
/**
 * Role constants for the RBAC (Role-Based Access Control) system.
 */
public static final class Roles {
    public static final String ADMIN = "ROLE_ADMIN";
    public static final String USER = "ROLE_USER";
    public static final String PROFESSIONAL = "ROLE_PROFESSIONAL";
    public static final String CONSUMER = "ROLE_CONSUMER";
}

/**
 * Permission-related constants for the advanced permissions system.
 */
public static final class Permissions {
    public static final class PermissionLk {
        public static final String QUOTE = "QUOTE";
        public static final String USER_MANAGEMENT = "USER_MANAGEMENT";
        public static final String REPORT = "REPORT";
        public static final String PROFILE = "PROFILE";
    }

    public static final class PermissionLevelLk {
        public static final String NONE = "NONE";
        public static final String READ = "READ";
        public static final String EDIT = "EDIT";
        public static final String CREATE = "CREATE";
        public static final String DELETE = "DELETE";
        
        // Bitwise values for level checking
        public static final Integer NONE_VALUE = 0b0000;
        public static final Integer READ_VALUE = 0b0001;
        public static final Integer EDIT_VALUE = 0b0011;
        public static final Integer CREATE_VALUE = 0b0111;
        public static final Integer DELETE_VALUE = 0b1111;
    }

    public static final class PermissionTargetLk {
        public static final String ALL = "ALL";
        public static final String SELF = "SELF";
        public static final String PROFESSIONALS = "PROFESSIONALS";
        public static final String CONSUMERS = "CONSUMERS";
        public static final String TEAM = "TEAM";
        public static final String ORGANIZATION = "ORGANIZATION";
    }
}
```

### Spring Security Configuration

```java
@Configuration
@EnableWebSecurity
@EnableGlobalMethodSecurity(prePostEnabled = true, securedEnabled = true, jsr250Enabled = true)
public class SecurityConfig {

    @Autowired
    private CustomUserDetailsService userDetailsService;

    @Bean
    public PasswordEncoder passwordEncoder() {
        return new BCryptPasswordEncoder();
    }

    @Bean
    public AuthenticationManager authenticationManager(
            AuthenticationConfiguration config) throws Exception {
        return config.getAuthenticationManager();
    }

    @Bean
    public DaoAuthenticationProvider authenticationProvider() {
        DaoAuthenticationProvider authProvider = new DaoAuthenticationProvider();
        authProvider.setUserDetailsService(userDetailsService);
        authProvider.setPasswordEncoder(passwordEncoder());
        return authProvider;
    }

    @Override
    protected void configure(HttpSecurity http) throws Exception {
        http.csrf().disable()
            .authorizeHttpRequests(authz -> authz
                .requestMatchers("/api/auth/**").permitAll()
                .requestMatchers("/api/admin/**").hasRole("ADMIN")
                .requestMatchers("/api/professional/**").hasRole("PROFESSIONAL")
                .anyRequest().authenticated()
            )
            .sessionManagement()
                .sessionCreationPolicy(SessionCreationPolicy.STATELESS);
    }
}
```

### Unified Access Control Service

```java
@Service
public class AccessControlService {

    @Autowired
    private RoleService roleService;
    
    @Autowired
    private PermissionService permissionService;

    /**
     * Check if user has access using role-based check first, then permissions.
     */
    public boolean hasAccess(User user, String resource, String operation) {
        // First check if user has admin role (full access)
        if (roleService.hasRole(user, Constants.Roles.ADMIN)) {
            return true;
        }
        
        // Then check specific role requirements
        if (checkRoleBasedAccess(user, resource, operation)) {
            return true;
        }
        
        // Finally check specific permissions
        return checkPermissionBasedAccess(user, resource, operation);
    }

    /**
     * Check access using both roles and permissions for fine-grained control.
     */
    public boolean hasPermission(User userToCheck, User userContext, 
                               String permissionLk, String permissionLevelLk, 
                               String permissionTargetLk) {
        
        // Admin role bypasses all permission checks
        if (roleService.hasRole(userToCheck, Constants.Roles.ADMIN)) {
            return true;
        }
        
        return permissionService.hasPermission(userToCheck, userContext, 
            permissionLk, permissionLevelLk, permissionTargetLk);
    }

    private boolean checkRoleBasedAccess(User user, String resource, String operation) {
        switch (resource.toLowerCase()) {
            case "quotes":
                return roleService.hasRole(user, Constants.Roles.PROFESSIONAL) ||
                       roleService.hasRole(user, Constants.Roles.ADMIN);
            case "users":
                return roleService.hasRole(user, Constants.Roles.ADMIN);
            case "reports":
                return roleService.hasRole(user, Constants.Roles.PROFESSIONAL) ||
                       roleService.hasRole(user, Constants.Roles.ADMIN);
            default:
                return roleService.hasRole(user, Constants.Roles.USER);
        }
    }

    private boolean checkPermissionBasedAccess(User user, String resource, String operation) {
        String permissionLk = mapResourceToPermission(resource);
        String levelLk = mapOperationToLevel(operation);
        
        if (permissionLk == null || levelLk == null) {
            return false;
        }
        
        return permissionService.hasPermission(user, permissionLk, levelLk);
    }

    private String mapResourceToPermission(String resource) {
        switch (resource.toLowerCase()) {
            case "quotes": return Constants.Permissions.PermissionLk.QUOTE;
            case "users": return Constants.Permissions.PermissionLk.USER_MANAGEMENT;
            case "reports": return Constants.Permissions.PermissionLk.REPORT;
            case "profile": return Constants.Permissions.PermissionLk.PROFILE;
            default: return null;
        }
    }

    private String mapOperationToLevel(String operation) {
        switch (operation.toLowerCase()) {
            case "read": case "view": case "get":
                return Constants.Permissions.PermissionLevelLk.READ;
            case "edit": case "update": case "put":
                return Constants.Permissions.PermissionLevelLk.EDIT;
            case "create": case "post":
                return Constants.Permissions.PermissionLevelLk.CREATE;
            case "delete":
                return Constants.Permissions.PermissionLevelLk.DELETE;
            default: return null;
        }
    }
}
```

### Usage Examples

#### Simple Role-Based Access

```java
@RestController
@RequestMapping("/api/quotes")
public class QuoteController {

    @GetMapping
    @PreAuthorize("hasRole('USER')")
    public List<Quote> getQuotes(@CurrentUser User currentUser) {
        return quoteService.getUserQuotes(currentUser.getId());
    }

    @PostMapping
    @PreAuthorize("hasRole('PROFESSIONAL') or hasRole('ADMIN')")
    public ResponseObject<Quote> createQuote(@RequestBody QuoteRequest request) {
        return ResponseObject.success(quoteService.createQuote(request));
    }
}
```

#### Advanced Permission-Based Access

```java
@Service
public class QuoteService {
    
    @Autowired
    private PermissionService permissionService;
    
    public void updateQuote(Long quoteId, User currentUser, QuoteUpdateRequest request) {
        // Check if user can edit quotes for professionals
        if (!permissionService.hasPermission(
                currentUser, 
                currentUser,
                Constants.Permissions.PermissionLk.QUOTE,
                Constants.Permissions.PermissionLevelLk.EDIT,
                Constants.Permissions.PermissionTargetLk.PROFESSIONALS)) {
            throw new AccessDeniedException("Insufficient permissions");
        }
        
        doUpdateQuote(quoteId, request);
    }
}
```

### Advanced Permission Service Implementation

```java
@Service
public class PermissionService {

    private final PermissionDao permissionDao;
    private final Dao<PermissionLevelLkDb, String> levelDao;
    private final Map<String, Integer> levelValueCache;

    @Autowired
    public PermissionService(PermissionDao permissionDao, DaoFactory daoFactory) {
        this.permissionDao = permissionDao;
        this.levelDao = daoFactory.getDao(PermissionLevelLkDb.class, String.class);
        this.levelValueCache = loadLevelValues();
    }

    /**
     * Main permission checking method with full flexibility.
     */
    public boolean hasPermission(User userToCheck, User userContext, 
                               String permissionLk, String permissionLevelLk, 
                               String permissionTargetLk) {
        
        if (userToCheck == null || permissionLk == null) {
            return false;
        }

        List<UserPermissionDb> userPermissions = permissionDao.getUserPermissions(
            userToCheck.getId(), permissionLk);

        if (userPermissions.isEmpty()) {
            return false;
        }

        // Check each permission against the requirements
        return userPermissions.stream().anyMatch(permission -> 
            matchesTargetRequirement(permission, permissionTargetLk, userToCheck, userContext) &&
            matchesLevelRequirement(permission, permissionLevelLk)
        );
    }

    /**
     * Grant a permission to a user.
     */
    public UserPermission grantPermission(Long userId, String permissionLk, 
                                        String permissionTargetLk, String permissionLevelLk, 
                                        Long grantedBy) {
        
        UserPermissionDb existing = permissionDao.getUserPermission(
            userId, permissionLk, permissionTargetLk, permissionLevelLk);
        
        if (existing != null) {
            throw new IllegalStateException("Permission already granted");
        }

        UserPermissionDb newPermission = new UserPermissionDb();
        newPermission.setUserId(userId);
        newPermission.setPermissionLk(permissionLk);
        newPermission.setPermissionTargetLk(permissionTargetLk);
        newPermission.setPermissionLevelLk(permissionLevelLk);
        newPermission.setGrantedBy(grantedBy);

        permissionDao.insertUserPermission(newPermission);
        return convertToBusinessModel(newPermission);
    }

    private boolean matchesTargetRequirement(UserPermissionDb permission, String requiredTarget, 
                                           User userToCheck, User userContext) {
        if (requiredTarget == null && permission.getPermissionTargetLk() == null) {
            return true;
        }
        
        if (requiredTarget == null || permission.getPermissionTargetLk() == null) {
            return false;
        }

        String userTarget = permission.getPermissionTargetLk();
        
        switch (userTarget) {
            case Constants.Permissions.PermissionTargetLk.ALL:
                return true;
            case Constants.Permissions.PermissionTargetLk.SELF:
                return userContext != null && userToCheck.getId().equals(userContext.getId());
            default:
                return userTarget.equals(requiredTarget);
        }
    }

    private boolean matchesLevelRequirement(UserPermissionDb permission, String requiredLevel) {
        if (requiredLevel == null && permission.getPermissionLevelLk() == null) {
            return true;
        }
        
        if (requiredLevel == null || permission.getPermissionLevelLk() == null) {
            return false;
        }

        Integer userLevelValue = levelValueCache.get(permission.getPermissionLevelLk());
        Integer requiredLevelValue = levelValueCache.get(requiredLevel);
        
        if (userLevelValue == null || requiredLevelValue == null) {
            return false;
        }

        // Bitwise check: user must have at least the required level
        return (userLevelValue & requiredLevelValue) == requiredLevelValue;
    }

    private Map<String, Integer> loadLevelValues() {
        PermissionLevelLkDbExample example = new PermissionLevelLkDbExample();
        List<PermissionLevelLkDb> levels = levelDao.select(example);
        
        return levels.stream()
            .collect(Collectors.toMap(
                PermissionLevelLkDb::getPermissionLevelLk,
                PermissionLevelLkDb::getLevelValue
            ));
    }
}
```

### Permission DAO Implementation

```java
@Repository
public class PermissionDao {

    private final Dao<UserPermissionDb, String> userPermissionDao;

    @Autowired
    public PermissionDao(DaoFactory daoFactory) {
        this.userPermissionDao = daoFactory.getDao(UserPermissionDb.class, String.class);
    }

    public List<UserPermissionDb> getUserPermissions(Long userId) {
        UserPermissionDbExample example = new UserPermissionDbExample();
        example.createCriteria().andUserIdEqualTo(userId);
        return userPermissionDao.select(example);
    }

    public List<UserPermissionDb> getUserPermissions(Long userId, String permissionLk) {
        UserPermissionDbExample example = new UserPermissionDbExample();
        example.createCriteria()
            .andUserIdEqualTo(userId)
            .andPermissionLkEqualTo(permissionLk);
        return userPermissionDao.select(example);
    }

    public UserPermissionDb getUserPermission(Long userId, String permissionLk, 
                                            String targetLk, String levelLk) {
        UserPermissionDbExample example = new UserPermissionDbExample();
        var criteria = example.createCriteria()
            .andUserIdEqualTo(userId)
            .andPermissionLkEqualTo(permissionLk);
        
        if (targetLk != null) {
            criteria.andPermissionTargetLkEqualTo(targetLk);
        } else {
            criteria.andPermissionTargetLkIsNull();
        }
        
        if (levelLk != null) {
            criteria.andPermissionLevelLkEqualTo(levelLk);
        } else {
            criteria.andPermissionLevelLkIsNull();
        }
        
        return userPermissionDao.select(example).stream().findFirst().orElse(null);
    }

    public int insertUserPermission(UserPermissionDb userPermission) {
        return userPermissionDao.insert(userPermission);
    }

    public int deleteUserPermission(String userPermissionId) {
        return userPermissionDao.delete(userPermissionId);
    }
}
```

### Custom Security Annotation

```java
@Target(ElementType.METHOD)
@Retention(RetentionPolicy.RUNTIME)
public @interface RequirePermission {
    String permission();
    String level() default "";
    String target() default "";
    boolean checkSelf() default false;
}

@Aspect
@Component
public class PermissionAspect {
    
    @Autowired
    private AccessControlService accessControl;
    
    @Before("@annotation(requirePermission)")
    public void checkPermission(JoinPoint joinPoint, RequirePermission requirePermission) {
        User currentUser = getCurrentUser(); // Extract from security context
        
        boolean hasAccess;
        if (requirePermission.level().isEmpty() && requirePermission.target().isEmpty()) {
            // Simple role-based check
            hasAccess = accessControl.hasRole(currentUser, requirePermission.permission());
        } else {
            // Advanced permission check
            User targetUser = requirePermission.checkSelf() ? currentUser : extractTargetUser(joinPoint);
            hasAccess = accessControl.hasPermission(
                currentUser,
                targetUser,
                requirePermission.permission(),
                requirePermission.level().isEmpty() ? null : requirePermission.level(),
                requirePermission.target().isEmpty() ? null : requirePermission.target()
            );
        }
        
        if (!hasAccess) {
            throw new AccessDeniedException("Insufficient permissions");
        }
    }
}

// Usage examples:
@RequirePermission(permission = Constants.Roles.ADMIN)
public void adminOnlyMethod() { }

@RequirePermission(
    permission = Constants.Permissions.PermissionLk.QUOTE,
    level = Constants.Permissions.PermissionLevelLk.EDIT,
    target = Constants.Permissions.PermissionTargetLk.PROFESSIONALS
)
public void editProfessionalQuotes() { }
```

## 🔗 Dependencies & Integration Points

### Existing Components
- **User System**: Extends existing User model and authentication
- **MyBatis**: Uses existing DAO patterns for both roles and permissions
- **JWT Service**: Integrates roles and permissions into JWT token claims
- **Security Config**: Enhances existing security configuration

### New Dependencies
- **Spring Security Method Security**: For @PreAuthorize annotations
- **Spring Security Core**: For UserDetailsService integration
- **Performance**: Consider Redis for caching permission lookups

## 🧪 Testing Strategy

### Test Scenarios
1. **Role-Based Access**: Test simple role assignments and checks
2. **Permission-Based Access**: Test complex permission scenarios
3. **Hybrid Access**: Test combinations of roles and permissions
4. **Performance**: Ensure permission checks don't impact response times
5. **Security**: Test unauthorized access attempts and privilege escalation

### Example Test

```java
@SpringBootTest
class AccessControlServiceTest {
    
    @Autowired
    private AccessControlService accessControl;
    
    @Test
    void testRoleBasedAccess() {
        User user = createUserWithRole(Constants.Roles.PROFESSIONAL);
        assertTrue(accessControl.hasAccess(user, "quotes", "read"));
        assertFalse(accessControl.hasAccess(user, "users", "edit"));
    }
    
    @Test
    void testPermissionBasedAccess() {
        User user = createUserWithPermission(
            Constants.Permissions.PermissionLk.QUOTE,
            Constants.Permissions.PermissionLevelLk.EDIT,
            Constants.Permissions.PermissionTargetLk.PROFESSIONALS
        );
        
        assertTrue(accessControl.hasPermission(user, user,
            Constants.Permissions.PermissionLk.QUOTE,
            Constants.Permissions.PermissionLevelLk.READ,
            Constants.Permissions.PermissionTargetLk.PROFESSIONALS));
    }
}
```

## 🚀 Deployment Considerations

### Migration Strategy
1. **Phase 1**: Deploy basic RBAC system, assign roles to existing users
2. **Phase 2**: Add permissions tables, no functionality changes
3. **Phase 3**: Gradually migrate complex authorization to permission-based
4. **Phase 4**: Optimize and cache permission lookups

### Environment Variables
- **RBAC_CACHE_TTL**: Time-to-live for role caching (default: 300 seconds)
- **PERMISSION_CACHE_TTL**: Time-to-live for permission caching (default: 600 seconds)

### Performance Considerations
- Use database indexes on user_roles and user_permissions tables
- Implement caching for frequently checked permissions
- Consider async permission loading for non-critical checks

## 📊 Success Metrics
- **Authorization Coverage**: All endpoints protected appropriately
- **Performance Impact**: Role checks < 5ms, permission checks < 15ms
- **Developer Adoption**: 90% of new endpoints use appropriate authorization
- **Security Compliance**: Zero unauthorized access incidents

## 🔄 Next Steps

### Immediate (Week 1)
1. **Implement RBAC Foundation**: Create roles tables and basic Spring Security integration
2. **Update Constants**: Add role constants for immediate use
3. **Basic Testing**: Ensure existing authentication still works

### Short-term (Month 1)
1. **Complete RBAC Implementation**: All role management functionality
2. **Add Permissions Schema**: Create tables for advanced permissions
3. **Unified Service**: Implement AccessControlService combining both approaches

### Long-term (Quarter 1)
1. **Advanced Permission Features**: Complete permission management
2. **Performance Optimization**: Implement caching and optimize queries
3. **Migration Tools**: Provide utilities for converting role-based rules to permissions

## 📝 When to Use Each Approach

### Use RBAC (Roles) When:
- **Simple Authorization**: Basic user types (admin, user, professional)
- **Course-Grained Access**: Protecting entire endpoints or services
- **Getting Started**: Initial implementation or proof of concept
- **Spring Security Integration**: Leveraging @PreAuthorize annotations

### Use Advanced Permissions When:
- **Fine-Grained Control**: User can edit their own quotes but not others'
- **Complex Business Logic**: Different access levels based on data context
- **Dynamic Permissions**: Permissions granted/revoked frequently
- **Regulatory Compliance**: Detailed audit trails and specific access controls

### Use Both Together When:
- **Layered Security**: Roles for basic access, permissions for detailed control
- **Migration Path**: Starting with roles, gradually adding permissions
- **Performance Optimization**: Roles for fast checks, permissions for complex scenarios

---
**Implementation Status**: ⏳ Planning  
**Review Required**: Yes - by security team and lead developer 