---
description: 
globs: 
alwaysApply: false
---
## Implementation Guide Generation Rule

### When to Apply This Rule
Trigger this rule when a user request involves:
- Complex system integrations (databases, authentication, permissions)
- Multi-step implementation processes requiring coordination between multiple components
- New feature development that spans multiple files/services
- Architectural changes requiring careful planning and validation

### Actions

### 0. Introspective Analysis Phase
**Before creating any implementation guide, ask these critical questions:**

#### Prompt Understanding
- What is the core business requirement behind this request?
- What are the technical constraints and dependencies?
- What existing patterns in the codebase should be followed?
- Are there security, performance, or scalability implications?

#### Scope Definition
- What components need to be created vs modified?
- What are the integration points with existing systems?
- What are the potential breaking changes or migration requirements?
- What testing strategies are needed?

#### Risk Assessment
- What could go wrong during implementation?
- What are the rollback strategies?
- What external dependencies might cause issues?
- What are the maintenance implications?

### 1. Task Naming and Documentation Structure
Create documentation file path: `/docs/{task-name}.md`

**Task naming convention:**
- Use kebab-case format
- Include primary domain (e.g., `permissions-system`, `oauth-integration`)
- Be descriptive but concise
- Examples: `permissions-rbac-implementation.md`, `oauth-google-integration.md`

### 2. Documentation Template Structure

```markdown
# {Task Name} Implementation Guide

> **Generated by**: Cursor AI Assistant  
> **Created**: {Date}  
> **Last Updated**: {Date}  
> **Status**: Planning | In Progress | Complete | Blocked

## ğŸ¯ Objective
{Clear business objective and technical goal}

## ğŸ” Introspective Analysis

### Business Requirements
- **Primary Goal**: {What business problem are we solving?}
- **Success Criteria**: {How do we measure success?}
- **User Impact**: {How does this affect end users?}

### Technical Analysis
- **Integration Points**: {What systems need to connect?}
- **Dependencies**: {What existing code/systems are required?}
- **Constraints**: {What limitations exist?}
- **Assumptions**: {What are we assuming to be true?}

### Risk Assessment
- **High Risk**: {Critical failure points}
- **Medium Risk**: {Moderate concerns}
- **Mitigation Strategies**: {How to address risks}

## ğŸ“‹ Implementation Checklist

### Phase 1: Database & Schema
- [ ] **Database Migration**: Create tables/columns
  - [ ] {Specific table 1}
  - [ ] {Specific table 2}
- [ ] **MyBatis Integration**: Generate mappers and models
  - [ ] Update mybatis-generator-config.xml
  - [ ] Run MyBatis generator
  - [ ] Verify generated files
- [ ] **Database Testing**: Validate schema and relationships
  - [ ] Test table creation
  - [ ] Test foreign key constraints
  - [ ] Test data insertion/retrieval

### Phase 2: Core Business Logic
- [ ] **Domain Models**: Create/update business objects
  - [ ] {Specific model 1}
  - [ ] {Specific model 2}
- [ ] **Service Layer**: Implement business logic
  - [ ] {Specific service 1}
  - [ ] {Specific service 2}
- [ ] **DAO Integration**: Connect services to data layer
  - [ ] Configure DAO factories
  - [ ] Implement data access patterns

### Phase 3: API & Controllers
- [ ] **REST Endpoints**: Create/update controllers
  - [ ] {Endpoint 1}
  - [ ] {Endpoint 2}
- [ ] **Request/Response Models**: Define API contracts
- [ ] **Validation**: Implement input validation
- [ ] **Error Handling**: Add proper exception handling

### Phase 4: Security & Authorization
- [ ] **Authentication Integration**: Connect with existing auth
- [ ] **Authorization Rules**: Implement permission checks
- [ ] **Security Testing**: Validate access controls

### Phase 5: Integration & Testing
- [ ] **Unit Tests**: Test individual components
- [ ] **Integration Tests**: Test component interactions
- [ ] **End-to-End Tests**: Test complete user flows
- [ ] **Performance Testing**: Validate under load

### Phase 6: Documentation & Deployment
- [ ] **API Documentation**: Update OpenAPI/Swagger docs
- [ ] **Code Documentation**: Add JavaDoc comments
- [ ] **Deployment Scripts**: Update CI/CD if needed
- [ ] **Migration Scripts**: Prepare production deployment

## ğŸ—ï¸ Implementation Details

### Database Schema
```sql
{Include relevant SQL from DBML}
```

### Code Examples
```java
{Include key code snippets showing integration patterns}
```

### Configuration Changes
```properties
{List any application.properties changes}
```

## ğŸ”— Dependencies & Integration Points

### Existing Components
- **{Component 1}**: {How it integrates}
- **{Component 2}**: {How it integrates}

### External Dependencies
- **{Dependency 1}**: {Version and purpose}
- **{Dependency 2}**: {Version and purpose}

## ğŸ§ª Testing Strategy

### Test Scenarios
1. **{Scenario 1}**: {Expected behavior}
2. **{Scenario 2}**: {Expected behavior}

### Test Data Requirements
- **{Data type 1}**: {Requirements}
- **{Data type 2}**: {Requirements}

## ğŸš€ Deployment Considerations

### Environment Variables
- **{VAR_NAME}**: {Description and example value}

### Database Migrations
1. **{Migration 1}**: {Description}
2. **{Migration 2}**: {Description}

### Rollback Plan
1. **{Step 1}**: {Rollback procedure}
2. **{Step 2}**: {Rollback procedure}

## ğŸ“Š Success Metrics
- **{Metric 1}**: {How to measure}
- **{Metric 2}**: {How to measure}

## ğŸ”„ Next Steps
1. **Immediate**: {Next action required}
2. **Short-term**: {Actions for this sprint}
3. **Long-term**: {Future considerations}

---
**Implementation Status**: â³ Planning | ğŸ”¨ In Progress | âœ… Complete | âŒ Blocked  
**Review Required**: {Yes/No and by whom}
```

### 3. Implementation Process
1. **Analysis Phase**: Complete introspective analysis
2. **Documentation Creation**: Generate the implementation guide in `/docs/`
3. **Checklist Review**: Walk through each checklist item with the user
4. **Implementation Start**: Begin with database/schema changes
5. **Iterative Updates**: Update checklist as work progresses
6. **Final Review**: Validate completion against original objectives

### 4. Collaboration Guidelines
- **AI Assistant Role**: 
  - Generate initial analysis and documentation
  - Provide code examples and integration patterns
  - Update checklists based on progress
  - Validate implementation against design

- **Developer Role**:
  - Review and refine the implementation guide
  - Execute checklist items and mark completion
  - Add additional considerations or risks
  - Update status and next steps

### 5. Quality Gates
Before marking any phase complete:
- [ ] All checklist items in phase are verified
- [ ] Integration points are tested
- [ ] Documentation is updated
- [ ] Code follows existing patterns and standards
- [ ] Security implications are addressed

## Expected Outcome
A comprehensive, living document that:
- âœ… Provides clear implementation roadmap
- âœ… Identifies risks and mitigation strategies  
- âœ… Includes executable checklist items
- âœ… Maintains alignment with business objectives
- âœ… Supports both AI and human collaboration
- âœ… Enables tracking progress and blockers
